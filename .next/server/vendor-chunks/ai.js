"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\");\n        return decoded.map(getStreamStringTypeAndValue).filter(Boolean);\n    };\n}\nvar StreamStringPrefixes = {\n    text: 0,\n    function_call: 1,\n    data: 2\n};\nvar getStreamStringTypeAndValue = (line)=>{\n    const firstSeperatorIndex = line.indexOf(\":\");\n    const prefix = line.slice(0, firstSeperatorIndex);\n    const type = Object.keys(StreamStringPrefixes).find((key)=>StreamStringPrefixes[key] === Number(prefix));\n    const val = line.slice(firstSeperatorIndex + 1);\n    let parsedVal = val;\n    if (!val) {\n        return {\n            type,\n            value: \"\"\n        };\n    }\n    try {\n        parsedVal = JSON.parse(val);\n    } catch (e) {\n        console.error(\"Failed to parse JSON value:\", val);\n    }\n    return {\n        type,\n        value: parsedVal\n    };\n};\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const res = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages: sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call })=>({\n                    role,\n                    content,\n                    ...name !== void 0 && {\n                        name\n                    },\n                    ...function_call !== void 0 && {\n                        function_call\n                    }\n                })),\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            }\n        }),\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        ...abortControllerRef.current !== null && {\n            signal: abortControllerRef.current.signal\n        }\n    }).catch((err)=>{\n        mutate(previousMessages, false);\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(res);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!res.ok) {\n        mutate(previousMessages, false);\n        throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!res.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n    const createdAt = /* @__PURE__ */ new Date();\n    const reader = res.body.getReader();\n    const decode = createChunkDecoder(isComplexMode);\n    let responseMessages = [];\n    let responseData = [];\n    const prefixMap = {};\n    const NEWLINE = \"\\n\".charCodeAt(0);\n    let chunks = [];\n    let totalLength = 0;\n    if (isComplexMode) {\n        while(true){\n            const { value } = await reader.read();\n            if (value) {\n                chunks.push(value);\n                totalLength += value.length;\n                if (value[value.length - 1] !== NEWLINE) {\n                    continue;\n                }\n            }\n            if (chunks.length === 0) {\n                break;\n            }\n            let concatenatedChunks = new Uint8Array(totalLength);\n            let offset = 0;\n            for (const chunk of chunks){\n                concatenatedChunks.set(chunk, offset);\n                offset += chunk.length;\n            }\n            chunks.length = 0;\n            totalLength = 0;\n            const lines = decode(concatenatedChunks);\n            if (typeof lines === \"string\") {\n                throw new Error(\"Invalid response format. Complex mode was set but the response is a string. This should never happen.\");\n            }\n            for (const { type, value: value2 } of lines){\n                if (type === \"text\") {\n                    if (prefixMap[\"text\"]) {\n                        prefixMap[\"text\"] = {\n                            ...prefixMap[\"text\"],\n                            content: (prefixMap[\"text\"].content || \"\") + value2\n                        };\n                    } else {\n                        prefixMap[\"text\"] = {\n                            id: nanoid(),\n                            role: \"assistant\",\n                            content: value2,\n                            createdAt\n                        };\n                    }\n                }\n                let functionCallMessage = null;\n                if (type === \"function_call\") {\n                    prefixMap[\"function_call\"] = value2;\n                    let functionCall = prefixMap[\"function_call\"];\n                    if (functionCall && typeof functionCall === \"string\") {\n                        const parsedFunctionCall = JSON.parse(functionCall).function_call;\n                        functionCallMessage = {\n                            id: nanoid(),\n                            role: \"assistant\",\n                            content: \"\",\n                            function_call: parsedFunctionCall,\n                            name: parsedFunctionCall.name,\n                            createdAt\n                        };\n                        prefixMap[\"function_call\"] = functionCallMessage;\n                    }\n                }\n                if (type === \"data\") {\n                    const parsedValue = JSON.parse(value2);\n                    if (prefixMap[\"data\"]) {\n                        prefixMap[\"data\"] = [\n                            ...prefixMap[\"data\"],\n                            ...parsedValue\n                        ];\n                    } else {\n                        prefixMap[\"data\"] = parsedValue;\n                    }\n                }\n                const data = prefixMap[\"data\"];\n                const responseMessage = prefixMap[\"text\"];\n                const merged = [\n                    functionCallMessage,\n                    responseMessage\n                ].filter(Boolean);\n                mutate([\n                    ...chatRequest.messages,\n                    ...merged\n                ], false);\n                mutateStreamData([\n                    ...existingData || [],\n                    ...data || []\n                ], false);\n                if (abortControllerRef.current === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n        }\n        for (const [type, item] of Object.entries(prefixMap)){\n            if (onFinish && type === \"text\") {\n                onFinish(item);\n            }\n            if (type === \"data\") {\n                responseData.push(item);\n            } else {\n                responseMessages.push(item);\n            }\n        }\n        return {\n            messages: responseMessages,\n            data: responseData\n        };\n    } else {\n        let streamedResponse = \"\";\n        const replyId = nanoid();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (abortControllerRef.current === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ]);\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages = [], initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, onResponse, onFinish, onError, credentials, headers, body } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const chatId = id || hookId;\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        chatId\n    ], null, {\n        fallbackData: initialMessages\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatId,\n        \"streamData\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)();\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            while(true){\n                const messagesAndDataOrJustMessage = await getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, onFinish, onResponse, sendExtraMessageFields);\n                if (\"messages\" in messagesAndDataOrJustMessage) {\n                    let hasFollowingResponse = false;\n                    for (const message of messagesAndDataOrJustMessage.messages){\n                        if (message.function_call === void 0 || typeof message.function_call === \"string\") {\n                            continue;\n                        }\n                        hasFollowingResponse = true;\n                        if (experimental_onFunctionCall) {\n                            const functionCall = message.function_call;\n                            const functionCallResponse = await experimental_onFunctionCall(messagesRef.current, functionCall);\n                            if (functionCallResponse === void 0) break;\n                            chatRequest = functionCallResponse;\n                        }\n                    }\n                    if (!hasFollowingResponse) {\n                        break;\n                    }\n                } else {\n                    const streamedResponseMessage = messagesAndDataOrJustMessage;\n                    if (streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") {\n                        break;\n                    }\n                    if (experimental_onFunctionCall) {\n                        const functionCall = streamedResponseMessage.function_call;\n                        const functionCallResponse = await experimental_onFunctionCall(messagesRef.current, functionCall);\n                        if (functionCallResponse === void 0) break;\n                        chatRequest = functionCallResponse;\n                    }\n                }\n            }\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        messagesRef.current,\n        abortControllerRef.current\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call } = {})=>{\n        if (!message.id) {\n            message.id = nanoid();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, { options, functions, function_call } = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, {\n            options,\n            functions,\n            function_call\n        });\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController2 = new AbortController();\n            setAbortController(abortController2);\n            mutate(\"\", false);\n            const res = await fetch(api, {\n                method: \"POST\",\n                body: JSON.stringify({\n                    prompt,\n                    ...extraMetadataRef.current.body,\n                    ...options == null ? void 0 : options.body\n                }),\n                credentials: extraMetadataRef.current.credentials,\n                headers: {\n                    ...extraMetadataRef.current.headers,\n                    ...options == null ? void 0 : options.headers\n                },\n                signal: abortController2.signal\n            }).catch((err)=>{\n                throw err;\n            });\n            if (onResponse) {\n                try {\n                    await onResponse(res);\n                } catch (err) {\n                    throw err;\n                }\n            }\n            if (!res.ok) {\n                throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n            }\n            if (!res.body) {\n                throw new Error(\"The response body is empty.\");\n            }\n            let result = \"\";\n            const reader = res.body.getReader();\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                mutate(result, false);\n                if (abortController2 === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n            if (onFinish) {\n                onFinish(prompt, result);\n            }\n            setAbortController(null);\n            return result;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                setAbortController(null);\n                return null;\n            }\n            if (err instanceof Error) {\n                if (onError) {\n                    onError(err);\n                }\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7MkVBRUEsb0JBQW9CO0FBQ29EO0FBQy9DO0FBRXpCLGtCQUFrQjtBQUNpQztBQUNuRCxJQUFJTyxTQUFTRCxpRUFBY0EsQ0FDekIsa0VBQ0E7QUFFRixTQUFTRSxtQkFBbUJDLE9BQU87SUFDakMsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixJQUFJLENBQUNGLFNBQVM7UUFDWixPQUFPLFNBQVNHLEtBQUs7WUFDbkIsSUFBSSxDQUFDQSxPQUNILE9BQU87WUFDVCxPQUFPRixRQUFRRyxNQUFNLENBQUNELE9BQU87Z0JBQUVFLFFBQVE7WUFBSztRQUM5QztJQUNGO0lBQ0EsT0FBTyxTQUFTRixLQUFLO1FBQ25CLE1BQU1HLFVBQVVMLFFBQVFHLE1BQU0sQ0FBQ0QsT0FBTztZQUFFRSxRQUFRO1FBQUssR0FBR0UsS0FBSyxDQUFDO1FBQzlELE9BQU9ELFFBQVFFLEdBQUcsQ0FBQ0MsNkJBQTZCQyxNQUFNLENBQUNDO0lBQ3pEO0FBQ0Y7QUFDQSxJQUFJQyx1QkFBdUI7SUFDekJDLE1BQU07SUFDTkMsZUFBZTtJQUNmQyxNQUFNO0FBRVI7QUFDQSxJQUFJTiw4QkFBOEIsQ0FBQ087SUFDakMsTUFBTUMsc0JBQXNCRCxLQUFLRSxPQUFPLENBQUM7SUFDekMsTUFBTUMsU0FBU0gsS0FBS0ksS0FBSyxDQUFDLEdBQUdIO0lBQzdCLE1BQU1JLE9BQU9DLE9BQU9DLElBQUksQ0FBQ1gsc0JBQXNCWSxJQUFJLENBQ2pELENBQUNDLE1BQVFiLG9CQUFvQixDQUFDYSxJQUFJLEtBQUtDLE9BQU9QO0lBRWhELE1BQU1RLE1BQU1YLEtBQUtJLEtBQUssQ0FBQ0gsc0JBQXNCO0lBQzdDLElBQUlXLFlBQVlEO0lBQ2hCLElBQUksQ0FBQ0EsS0FBSztRQUNSLE9BQU87WUFBRU47WUFBTVEsT0FBTztRQUFHO0lBQzNCO0lBQ0EsSUFBSTtRQUNGRCxZQUFZRSxLQUFLQyxLQUFLLENBQUNKO0lBQ3pCLEVBQUUsT0FBT0ssR0FBRztRQUNWQyxRQUFRQyxLQUFLLENBQUMsK0JBQStCUDtJQUMvQztJQUNBLE9BQU87UUFBRU47UUFBTVEsT0FBT0Q7SUFBVTtBQUNsQztBQUNBLElBQUlPLGlCQUFpQjtBQUVyQixvQkFBb0I7QUFDcEIsSUFBSUMsc0JBQXNCLE9BQU9DLEtBQUtDLGFBQWFDLFFBQVFDLGtCQUFrQkMsY0FBY0Msa0JBQWtCQyxhQUFhQyxvQkFBb0JDLFVBQVVDLFlBQVlDO0lBQ2xLLElBQUlDLElBQUlDO0lBQ1IsTUFBTUMsbUJBQW1CUCxZQUFZUSxPQUFPO0lBQzVDWixPQUFPRCxZQUFZYyxRQUFRLEVBQUU7SUFDN0IsTUFBTUMsTUFBTSxNQUFNQyxNQUFNakIsS0FBSztRQUMzQmtCLFFBQVE7UUFDUkMsTUFBTTFCLEtBQUsyQixTQUFTLENBQUM7WUFDbkJMLFVBQVVMLHlCQUF5QlQsWUFBWWMsUUFBUSxHQUFHZCxZQUFZYyxRQUFRLENBQUM1QyxHQUFHLENBQ2hGLENBQUMsRUFBRWtELElBQUksRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUU5QyxhQUFhLEVBQUUsR0FBTTtvQkFDM0M0QztvQkFDQUM7b0JBQ0EsR0FBR0MsU0FBUyxLQUFLLEtBQUs7d0JBQUVBO29CQUFLLENBQUM7b0JBQzlCLEdBQUc5QyxrQkFBa0IsS0FBSyxLQUFLO3dCQUM3QkE7b0JBQ0YsQ0FBQztnQkFDSDtZQUVGLEdBQUc0QixpQkFBaUJTLE9BQU8sQ0FBQ0ssSUFBSTtZQUNoQyxHQUFHLENBQUNSLEtBQUtWLFlBQVl1QixPQUFPLEtBQUssT0FBTyxLQUFLLElBQUliLEdBQUdRLElBQUk7WUFDeEQsR0FBR2xCLFlBQVl3QixTQUFTLEtBQUssS0FBSyxLQUFLO2dCQUNyQ0EsV0FBV3hCLFlBQVl3QixTQUFTO1lBQ2xDLENBQUM7WUFDRCxHQUFHeEIsWUFBWXhCLGFBQWEsS0FBSyxLQUFLLEtBQUs7Z0JBQ3pDQSxlQUFld0IsWUFBWXhCLGFBQWE7WUFDMUMsQ0FBQztRQUNIO1FBQ0FpRCxhQUFhckIsaUJBQWlCUyxPQUFPLENBQUNZLFdBQVc7UUFDakRDLFNBQVM7WUFDUCxHQUFHdEIsaUJBQWlCUyxPQUFPLENBQUNhLE9BQU87WUFDbkMsR0FBRyxDQUFDZixLQUFLWCxZQUFZdUIsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJWixHQUFHZSxPQUFPO1FBQzdEO1FBQ0EsR0FBR3BCLG1CQUFtQk8sT0FBTyxLQUFLLFFBQVE7WUFDeENjLFFBQVFyQixtQkFBbUJPLE9BQU8sQ0FBQ2MsTUFBTTtRQUMzQyxDQUFDO0lBQ0gsR0FBR0MsS0FBSyxDQUFDLENBQUNDO1FBQ1I1QixPQUFPVyxrQkFBa0I7UUFDekIsTUFBTWlCO0lBQ1I7SUFDQSxJQUFJckIsWUFBWTtRQUNkLElBQUk7WUFDRixNQUFNQSxXQUFXTztRQUNuQixFQUFFLE9BQU9jLEtBQUs7WUFDWixNQUFNQTtRQUNSO0lBQ0Y7SUFDQSxJQUFJLENBQUNkLElBQUllLEVBQUUsRUFBRTtRQUNYN0IsT0FBT1csa0JBQWtCO1FBQ3pCLE1BQU0sSUFBSW1CLE1BQU0sTUFBTWhCLElBQUl4QyxJQUFJLE1BQU07SUFDdEM7SUFDQSxJQUFJLENBQUN3QyxJQUFJRyxJQUFJLEVBQUU7UUFDYixNQUFNLElBQUlhLE1BQU07SUFDbEI7SUFDQSxNQUFNQyxnQkFBZ0JqQixJQUFJVyxPQUFPLENBQUNPLEdBQUcsQ0FBQ3BDLG9CQUFvQjtJQUMxRCxNQUFNcUMsWUFBWSxhQUFhLEdBQUcsSUFBSUM7SUFDdEMsTUFBTUMsU0FBU3JCLElBQUlHLElBQUksQ0FBQ21CLFNBQVM7SUFDakMsTUFBTXZFLFNBQVNMLG1CQUFtQnVFO0lBQ2xDLElBQUlNLG1CQUFtQixFQUFFO0lBQ3pCLElBQUlDLGVBQWUsRUFBRTtJQUNyQixNQUFNQyxZQUFZLENBQUM7SUFDbkIsTUFBTUMsVUFBVSxLQUFLQyxVQUFVLENBQUM7SUFDaEMsSUFBSUMsU0FBUyxFQUFFO0lBQ2YsSUFBSUMsY0FBYztJQUNsQixJQUFJWixlQUFlO1FBQ2pCLE1BQU8sS0FBTTtZQUNYLE1BQU0sRUFBRXpDLEtBQUssRUFBRSxHQUFHLE1BQU02QyxPQUFPUyxJQUFJO1lBQ25DLElBQUl0RCxPQUFPO2dCQUNUb0QsT0FBT0csSUFBSSxDQUFDdkQ7Z0JBQ1pxRCxlQUFlckQsTUFBTXdELE1BQU07Z0JBQzNCLElBQUl4RCxLQUFLLENBQUNBLE1BQU13RCxNQUFNLEdBQUcsRUFBRSxLQUFLTixTQUFTO29CQUN2QztnQkFDRjtZQUNGO1lBQ0EsSUFBSUUsT0FBT0ksTUFBTSxLQUFLLEdBQUc7Z0JBQ3ZCO1lBQ0Y7WUFDQSxJQUFJQyxxQkFBcUIsSUFBSUMsV0FBV0w7WUFDeEMsSUFBSU0sU0FBUztZQUNiLEtBQUssTUFBTXJGLFNBQVM4RSxPQUFRO2dCQUMxQkssbUJBQW1CRyxHQUFHLENBQUN0RixPQUFPcUY7Z0JBQzlCQSxVQUFVckYsTUFBTWtGLE1BQU07WUFDeEI7WUFDQUosT0FBT0ksTUFBTSxHQUFHO1lBQ2hCSCxjQUFjO1lBQ2QsTUFBTVEsUUFBUXRGLE9BQU9rRjtZQUNyQixJQUFJLE9BQU9JLFVBQVUsVUFBVTtnQkFDN0IsTUFBTSxJQUFJckIsTUFDUjtZQUVKO1lBQ0EsS0FBSyxNQUFNLEVBQUVoRCxJQUFJLEVBQUVRLE9BQU84RCxNQUFNLEVBQUUsSUFBSUQsTUFBTztnQkFDM0MsSUFBSXJFLFNBQVMsUUFBUTtvQkFDbkIsSUFBSXlELFNBQVMsQ0FBQyxPQUFPLEVBQUU7d0JBQ3JCQSxTQUFTLENBQUMsT0FBTyxHQUFHOzRCQUNsQixHQUFHQSxTQUFTLENBQUMsT0FBTzs0QkFDcEJuQixTQUFTLENBQUNtQixTQUFTLENBQUMsT0FBTyxDQUFDbkIsT0FBTyxJQUFJLEVBQUMsSUFBS2dDO3dCQUMvQztvQkFDRixPQUFPO3dCQUNMYixTQUFTLENBQUMsT0FBTyxHQUFHOzRCQUNsQmMsSUFBSTlGOzRCQUNKNEQsTUFBTTs0QkFDTkMsU0FBU2dDOzRCQUNUbkI7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSXFCLHNCQUFzQjtnQkFDMUIsSUFBSXhFLFNBQVMsaUJBQWlCO29CQUM1QnlELFNBQVMsQ0FBQyxnQkFBZ0IsR0FBR2E7b0JBQzdCLElBQUlHLGVBQWVoQixTQUFTLENBQUMsZ0JBQWdCO29CQUM3QyxJQUFJZ0IsZ0JBQWdCLE9BQU9BLGlCQUFpQixVQUFVO3dCQUNwRCxNQUFNQyxxQkFBcUJqRSxLQUFLQyxLQUFLLENBQ25DK0QsY0FDQWhGLGFBQWE7d0JBQ2YrRSxzQkFBc0I7NEJBQ3BCRCxJQUFJOUY7NEJBQ0o0RCxNQUFNOzRCQUNOQyxTQUFTOzRCQUNUN0MsZUFBZWlGOzRCQUNmbkMsTUFBTW1DLG1CQUFtQm5DLElBQUk7NEJBQzdCWTt3QkFDRjt3QkFDQU0sU0FBUyxDQUFDLGdCQUFnQixHQUFHZTtvQkFDL0I7Z0JBQ0Y7Z0JBQ0EsSUFBSXhFLFNBQVMsUUFBUTtvQkFDbkIsTUFBTTJFLGNBQWNsRSxLQUFLQyxLQUFLLENBQUM0RDtvQkFDL0IsSUFBSWIsU0FBUyxDQUFDLE9BQU8sRUFBRTt3QkFDckJBLFNBQVMsQ0FBQyxPQUFPLEdBQUc7K0JBQUlBLFNBQVMsQ0FBQyxPQUFPOytCQUFLa0I7eUJBQVk7b0JBQzVELE9BQU87d0JBQ0xsQixTQUFTLENBQUMsT0FBTyxHQUFHa0I7b0JBQ3RCO2dCQUNGO2dCQUNBLE1BQU1qRixPQUFPK0QsU0FBUyxDQUFDLE9BQU87Z0JBQzlCLE1BQU1tQixrQkFBa0JuQixTQUFTLENBQUMsT0FBTztnQkFDekMsTUFBTW9CLFNBQVM7b0JBQUNMO29CQUFxQkk7aUJBQWdCLENBQUN2RixNQUFNLENBQzFEQztnQkFFRjRCLE9BQU87dUJBQUlELFlBQVljLFFBQVE7dUJBQUs4QztpQkFBTyxFQUFFO2dCQUM3QzFELGlCQUFpQjt1QkFBSUMsZ0JBQWdCLEVBQUU7dUJBQUsxQixRQUFRLEVBQUU7aUJBQUMsRUFBRTtnQkFDekQsSUFBSTZCLG1CQUFtQk8sT0FBTyxLQUFLLE1BQU07b0JBQ3ZDdUIsT0FBT3lCLE1BQU07b0JBQ2I7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsS0FBSyxNQUFNLENBQUM5RSxNQUFNK0UsS0FBSyxJQUFJOUUsT0FBTytFLE9BQU8sQ0FBQ3ZCLFdBQVk7WUFDcEQsSUFBSWpDLFlBQVl4QixTQUFTLFFBQVE7Z0JBQy9Cd0IsU0FBU3VEO1lBQ1g7WUFDQSxJQUFJL0UsU0FBUyxRQUFRO2dCQUNuQndELGFBQWFPLElBQUksQ0FBQ2dCO1lBQ3BCLE9BQU87Z0JBQ0x4QixpQkFBaUJRLElBQUksQ0FBQ2dCO1lBQ3hCO1FBQ0Y7UUFDQSxPQUFPO1lBQUVoRCxVQUFVd0I7WUFBa0I3RCxNQUFNOEQ7UUFBYTtJQUMxRCxPQUFPO1FBQ0wsSUFBSXlCLG1CQUFtQjtRQUN2QixNQUFNQyxVQUFVekc7UUFDaEIsSUFBSW1HLGtCQUFrQjtZQUNwQkwsSUFBSVc7WUFDSi9CO1lBQ0FiLFNBQVM7WUFDVEQsTUFBTTtRQUNSO1FBQ0EsTUFBTyxLQUFNO1lBQ1gsTUFBTSxFQUFFOEMsSUFBSSxFQUFFM0UsS0FBSyxFQUFFLEdBQUcsTUFBTTZDLE9BQU9TLElBQUk7WUFDekMsSUFBSXFCLE1BQU07Z0JBQ1I7WUFDRjtZQUNBRixvQkFBb0JsRyxPQUFPeUI7WUFDM0IsSUFBSXlFLGlCQUFpQkcsVUFBVSxDQUFDLHNCQUFzQjtnQkFDcERSLGVBQWUsQ0FBQyxnQkFBZ0IsR0FBR0s7WUFDckMsT0FBTztnQkFDTEwsZUFBZSxDQUFDLFVBQVUsR0FBR0s7WUFDL0I7WUFDQS9ELE9BQU87bUJBQUlELFlBQVljLFFBQVE7Z0JBQUU7b0JBQUUsR0FBRzZDLGVBQWU7Z0JBQUM7YUFBRSxFQUFFO1lBQzFELElBQUlyRCxtQkFBbUJPLE9BQU8sS0FBSyxNQUFNO2dCQUN2Q3VCLE9BQU95QixNQUFNO2dCQUNiO1lBQ0Y7UUFDRjtRQUNBLElBQUlHLGlCQUFpQkcsVUFBVSxDQUFDLHNCQUFzQjtZQUNwRCxNQUFNVixxQkFBcUJqRSxLQUFLQyxLQUFLLENBQUN1RSxrQkFBa0J4RixhQUFhO1lBQ3JFbUYsZUFBZSxDQUFDLGdCQUFnQixHQUFHRjtZQUNuQ3hELE9BQU87bUJBQUlELFlBQVljLFFBQVE7Z0JBQUU7b0JBQUUsR0FBRzZDLGVBQWU7Z0JBQUM7YUFBRTtRQUMxRDtRQUNBLElBQUlwRCxVQUFVO1lBQ1pBLFNBQVNvRDtRQUNYO1FBQ0EsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsU0FBU1MsUUFBUSxFQUNmckUsTUFBTSxXQUFXLEVBQ2pCdUQsRUFBRSxFQUNGZSxrQkFBa0IsRUFBRSxFQUNwQkMsZUFBZSxFQUFFLEVBQ2pCN0Qsc0JBQXNCLEVBQ3RCOEQsMkJBQTJCLEVBQzNCL0QsVUFBVSxFQUNWRCxRQUFRLEVBQ1JpRSxPQUFPLEVBQ1AvQyxXQUFXLEVBQ1hDLE9BQU8sRUFDUFIsSUFBSSxFQUNMLEdBQUcsQ0FBQyxDQUFDO0lBQ0osTUFBTXVELFNBQVN0SCw0Q0FBS0E7SUFDcEIsTUFBTXVILFNBQVNwQixNQUFNbUI7SUFDckIsTUFBTSxFQUFFaEcsTUFBTXFDLFFBQVEsRUFBRWIsTUFBTSxFQUFFLEdBQUczQywrQ0FBTUEsQ0FBQztRQUFDeUM7UUFBSzJFO0tBQU8sRUFBRSxNQUFNO1FBQzdEQyxjQUFjTjtJQUNoQjtJQUNBLE1BQU0sRUFBRTVGLE1BQU1tRyxZQUFZLEtBQUssRUFBRTNFLFFBQVE0RSxhQUFhLEVBQUUsR0FBR3ZILCtDQUFNQSxDQUMvRDtRQUFDb0g7UUFBUTtLQUFVLEVBQ25CO0lBRUYsTUFBTSxFQUFFakcsTUFBTXFHLFVBQVUsRUFBRTdFLFFBQVFDLGdCQUFnQixFQUFFLEdBQUc1QywrQ0FBTUEsQ0FDM0Q7UUFBQ29IO1FBQVE7S0FBYSxFQUN0QjtJQUVGLE1BQU1yRSxjQUFjakQsNkNBQU1BLENBQUMwRCxZQUFZLEVBQUU7SUFDekM1RCxnREFBU0EsQ0FBQztRQUNSbUQsWUFBWVEsT0FBTyxHQUFHQyxZQUFZLEVBQUU7SUFDdEMsR0FBRztRQUFDQTtLQUFTO0lBQ2IsTUFBTVIscUJBQXFCbEQsNkNBQU1BLENBQUM7SUFDbEMsTUFBTWdELG1CQUFtQmhELDZDQUFNQSxDQUFDO1FBQzlCcUU7UUFDQUM7UUFDQVI7SUFDRjtJQUNBaEUsZ0RBQVNBLENBQUM7UUFDUmtELGlCQUFpQlMsT0FBTyxHQUFHO1lBQ3pCWTtZQUNBQztZQUNBUjtRQUNGO0lBQ0YsR0FBRztRQUFDTztRQUFhQztRQUFTUjtLQUFLO0lBQy9CLE1BQU0sQ0FBQ3RCLE9BQU9tRixTQUFTLEdBQUcxSCwrQ0FBUUE7SUFDbEMsTUFBTTJILGlCQUFpQi9ILGtEQUFXQSxDQUNoQyxPQUFPK0M7UUFDTCxJQUFJO1lBQ0Y2RSxjQUFjO1lBQ2RFLFNBQVMsS0FBSztZQUNkLE1BQU1FLGtCQUFrQixJQUFJQztZQUM1QjVFLG1CQUFtQk8sT0FBTyxHQUFHb0U7WUFDN0IsTUFBTyxLQUFNO2dCQUNYLE1BQU1FLCtCQUErQixNQUFNckYsb0JBQ3pDQyxLQUNBQyxhQUNBQyxRQUNBQyxrQkFDQTRFLFlBQ0ExRSxrQkFDQUMsYUFDQUMsb0JBQ0FDLFVBQ0FDLFlBQ0FDO2dCQUVGLElBQUksY0FBYzBFLDhCQUE4QjtvQkFDOUMsSUFBSUMsdUJBQXVCO29CQUMzQixLQUFLLE1BQU1DLFdBQVdGLDZCQUE2QnJFLFFBQVEsQ0FBRTt3QkFDM0QsSUFBSXVFLFFBQVE3RyxhQUFhLEtBQUssS0FBSyxLQUFLLE9BQU82RyxRQUFRN0csYUFBYSxLQUFLLFVBQVU7NEJBQ2pGO3dCQUNGO3dCQUNBNEcsdUJBQXVCO3dCQUN2QixJQUFJYiw2QkFBNkI7NEJBQy9CLE1BQU1mLGVBQWU2QixRQUFRN0csYUFBYTs0QkFDMUMsTUFBTThHLHVCQUF1QixNQUFNZiw0QkFDakNsRSxZQUFZUSxPQUFPLEVBQ25CMkM7NEJBRUYsSUFBSThCLHlCQUF5QixLQUFLLEdBQ2hDOzRCQUNGdEYsY0FBY3NGO3dCQUNoQjtvQkFDRjtvQkFDQSxJQUFJLENBQUNGLHNCQUFzQjt3QkFDekI7b0JBQ0Y7Z0JBQ0YsT0FBTztvQkFDTCxNQUFNRywwQkFBMEJKO29CQUNoQyxJQUFJSSx3QkFBd0IvRyxhQUFhLEtBQUssS0FBSyxLQUFLLE9BQU8rRyx3QkFBd0IvRyxhQUFhLEtBQUssVUFBVTt3QkFDakg7b0JBQ0Y7b0JBQ0EsSUFBSStGLDZCQUE2Qjt3QkFDL0IsTUFBTWYsZUFBZStCLHdCQUF3Qi9HLGFBQWE7d0JBQzFELE1BQU04Ryx1QkFBdUIsTUFBTWYsNEJBQ2pDbEUsWUFBWVEsT0FBTyxFQUNuQjJDO3dCQUVGLElBQUk4Qix5QkFBeUIsS0FBSyxHQUNoQzt3QkFDRnRGLGNBQWNzRjtvQkFDaEI7Z0JBQ0Y7WUFDRjtZQUNBaEYsbUJBQW1CTyxPQUFPLEdBQUc7UUFDL0IsRUFBRSxPQUFPZ0IsS0FBSztZQUNaLElBQUlBLElBQUlQLElBQUksS0FBSyxjQUFjO2dCQUM3QmhCLG1CQUFtQk8sT0FBTyxHQUFHO2dCQUM3QixPQUFPO1lBQ1Q7WUFDQSxJQUFJMkQsV0FBVzNDLGVBQWVFLE9BQU87Z0JBQ25DeUMsUUFBUTNDO1lBQ1Y7WUFDQWtELFNBQVNsRDtRQUNYLFNBQVU7WUFDUmdELGNBQWM7UUFDaEI7SUFDRixHQUNBO1FBQ0U1RTtRQUNBNEU7UUFDQTlFO1FBQ0FLO1FBQ0FJO1FBQ0FEO1FBQ0FpRTtRQUNBTztRQUNBN0U7UUFDQTRFO1FBQ0FyRTtRQUNBOEQ7UUFDQWxFLFlBQVlRLE9BQU87UUFDbkJQLG1CQUFtQk8sT0FBTztLQUMzQjtJQUVILE1BQU0yRSxTQUFTdkksa0RBQVdBLENBQ3hCLE9BQU9vSSxTQUFTLEVBQUU5RCxPQUFPLEVBQUVDLFNBQVMsRUFBRWhELGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUM2RyxRQUFRL0IsRUFBRSxFQUFFO1lBQ2YrQixRQUFRL0IsRUFBRSxHQUFHOUY7UUFDZjtRQUNBLE1BQU13QyxjQUFjO1lBQ2xCYyxVQUFVVCxZQUFZUSxPQUFPLENBQUM0RSxNQUFNLENBQUNKO1lBQ3JDOUQ7WUFDQSxHQUFHQyxjQUFjLEtBQUssS0FBSztnQkFBRUE7WUFBVSxDQUFDO1lBQ3hDLEdBQUdoRCxrQkFBa0IsS0FBSyxLQUFLO2dCQUFFQTtZQUFjLENBQUM7UUFDbEQ7UUFDQSxPQUFPd0csZUFBZWhGO0lBQ3hCLEdBQ0E7UUFBQ2dGO0tBQWU7SUFFbEIsTUFBTVUsU0FBU3pJLGtEQUFXQSxDQUN4QixPQUFPLEVBQUVzRSxPQUFPLEVBQUVDLFNBQVMsRUFBRWhELGFBQWEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMvQyxJQUFJNkIsWUFBWVEsT0FBTyxDQUFDa0MsTUFBTSxLQUFLLEdBQ2pDLE9BQU87UUFDVCxNQUFNNEMsY0FBY3RGLFlBQVlRLE9BQU8sQ0FBQ1IsWUFBWVEsT0FBTyxDQUFDa0MsTUFBTSxHQUFHLEVBQUU7UUFDdkUsSUFBSTRDLFlBQVl2RSxJQUFJLEtBQUssYUFBYTtZQUNwQyxNQUFNd0UsZUFBZTtnQkFDbkI5RSxVQUFVVCxZQUFZUSxPQUFPLENBQUMvQixLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUN4Q3lDO2dCQUNBLEdBQUdDLGNBQWMsS0FBSyxLQUFLO29CQUFFQTtnQkFBVSxDQUFDO2dCQUN4QyxHQUFHaEQsa0JBQWtCLEtBQUssS0FBSztvQkFBRUE7Z0JBQWMsQ0FBQztZQUNsRDtZQUNBLE9BQU93RyxlQUFlWTtRQUN4QjtRQUNBLE1BQU01RixjQUFjO1lBQ2xCYyxVQUFVVCxZQUFZUSxPQUFPO1lBQzdCVTtZQUNBLEdBQUdDLGNBQWMsS0FBSyxLQUFLO2dCQUFFQTtZQUFVLENBQUM7WUFDeEMsR0FBR2hELGtCQUFrQixLQUFLLEtBQUs7Z0JBQUVBO1lBQWMsQ0FBQztRQUNsRDtRQUNBLE9BQU93RyxlQUFlaEY7SUFDeEIsR0FDQTtRQUFDZ0Y7S0FBZTtJQUVsQixNQUFNYSxPQUFPNUksa0RBQVdBLENBQUM7UUFDdkIsSUFBSXFELG1CQUFtQk8sT0FBTyxFQUFFO1lBQzlCUCxtQkFBbUJPLE9BQU8sQ0FBQ2lGLEtBQUs7WUFDaEN4RixtQkFBbUJPLE9BQU8sR0FBRztRQUMvQjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU1rRixjQUFjOUksa0RBQVdBLENBQzdCLENBQUMrSTtRQUNDL0YsT0FBTytGLFdBQVc7UUFDbEIzRixZQUFZUSxPQUFPLEdBQUdtRjtJQUN4QixHQUNBO1FBQUMvRjtLQUFPO0lBRVYsTUFBTSxDQUFDZ0csT0FBT0MsU0FBUyxHQUFHN0ksK0NBQVFBLENBQUNpSDtJQUNuQyxNQUFNNkIsZUFBZWxKLGtEQUFXQSxDQUM5QixDQUFDeUMsR0FBRyxFQUFFNkIsT0FBTyxFQUFFQyxTQUFTLEVBQUVoRCxhQUFhLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFBRTRIO1FBQzlDLElBQUlBLFVBQVU7WUFDWmhHLGlCQUFpQlMsT0FBTyxHQUFHO2dCQUN6QixHQUFHVCxpQkFBaUJTLE9BQU87Z0JBQzNCLEdBQUd1RixRQUFRO1lBQ2I7UUFDRjtRQUNBMUcsRUFBRTJHLGNBQWM7UUFDaEIsSUFBSSxDQUFDSixPQUNIO1FBQ0ZULE9BQ0U7WUFDRW5FLFNBQVM0RTtZQUNUN0UsTUFBTTtZQUNOYyxXQUFXLGFBQWEsR0FBRyxJQUFJQztRQUNqQyxHQUNBO1lBQUVaO1lBQVNDO1lBQVdoRDtRQUFjO1FBRXRDMEgsU0FBUztJQUNYLEdBQ0E7UUFBQ0Q7UUFBT1Q7S0FBTztJQUVqQixNQUFNYyxvQkFBb0IsQ0FBQzVHO1FBQ3pCd0csU0FBU3hHLEVBQUU2RyxNQUFNLENBQUNoSCxLQUFLO0lBQ3pCO0lBQ0EsT0FBTztRQUNMdUIsVUFBVUEsWUFBWSxFQUFFO1FBQ3hCbEI7UUFDQTRGO1FBQ0FFO1FBQ0FHO1FBQ0FFO1FBQ0FFO1FBQ0FDO1FBQ0FJO1FBQ0FIO1FBQ0F2QjtRQUNBbkcsTUFBTXFHO0lBQ1I7QUFDRjtBQUVBLDBCQUEwQjtBQUM4RztBQUM5RztBQUMxQixTQUFTZ0MsY0FBYyxFQUNyQi9HLE1BQU0saUJBQWlCLEVBQ3ZCdUQsRUFBRSxFQUNGeUQsb0JBQW9CLEVBQUUsRUFDdEJ6QyxlQUFlLEVBQUUsRUFDakI3QyxXQUFXLEVBQ1hDLE9BQU8sRUFDUFIsSUFBSSxFQUNKVixVQUFVLEVBQ1ZELFFBQVEsRUFDUmlFLE9BQU8sRUFDUixHQUFHLENBQUMsQ0FBQztJQUNKLE1BQU1DLFNBQVNpQyw0Q0FBTUE7SUFDckIsTUFBTU0sZUFBZTFELE1BQU1tQjtJQUMzQixNQUFNLEVBQUVoRyxJQUFJLEVBQUV3QixNQUFNLEVBQUUsR0FBRzRHLCtDQUFPQSxDQUFDO1FBQUM5RztRQUFLaUg7S0FBYSxFQUFFLE1BQU07UUFDMURyQyxjQUFjb0M7SUFDaEI7SUFDQSxNQUFNLEVBQUV0SSxNQUFNbUcsWUFBWSxLQUFLLEVBQUUzRSxRQUFRNEUsYUFBYSxFQUFFLEdBQUdnQywrQ0FBT0EsQ0FDaEU7UUFBQ0c7UUFBYztLQUFVLEVBQ3pCO0lBRUYsTUFBTSxDQUFDcEgsT0FBT21GLFNBQVMsR0FBRzZCLCtDQUFTQSxDQUFDLEtBQUs7SUFDekMsTUFBTUssYUFBYXhJO0lBQ25CLE1BQU0sQ0FBQ3dHLGlCQUFpQmlDLG1CQUFtQixHQUFHTiwrQ0FBU0EsQ0FBQztJQUN4RCxNQUFNeEcsbUJBQW1CdUcsNkNBQU9BLENBQUM7UUFDL0JsRjtRQUNBQztRQUNBUjtJQUNGO0lBQ0F1RixnREFBVUEsQ0FBQztRQUNUckcsaUJBQWlCUyxPQUFPLEdBQUc7WUFDekJZO1lBQ0FDO1lBQ0FSO1FBQ0Y7SUFDRixHQUFHO1FBQUNPO1FBQWFDO1FBQVNSO0tBQUs7SUFDL0IsTUFBTThELGlCQUFpQndCLGtEQUFZQSxDQUNqQyxPQUFPVyxRQUFRNUY7UUFDYixJQUFJO1lBQ0ZzRCxjQUFjO1lBQ2RFLFNBQVMsS0FBSztZQUNkLE1BQU1xQyxtQkFBbUIsSUFBSWxDO1lBQzdCZ0MsbUJBQW1CRTtZQUNuQm5ILE9BQU8sSUFBSTtZQUNYLE1BQU1jLE1BQU0sTUFBTUMsTUFBTWpCLEtBQUs7Z0JBQzNCa0IsUUFBUTtnQkFDUkMsTUFBTTFCLEtBQUsyQixTQUFTLENBQUM7b0JBQ25CZ0c7b0JBQ0EsR0FBRy9HLGlCQUFpQlMsT0FBTyxDQUFDSyxJQUFJO29CQUNoQyxHQUFHSyxXQUFXLE9BQU8sS0FBSyxJQUFJQSxRQUFRTCxJQUFJO2dCQUM1QztnQkFDQU8sYUFBYXJCLGlCQUFpQlMsT0FBTyxDQUFDWSxXQUFXO2dCQUNqREMsU0FBUztvQkFDUCxHQUFHdEIsaUJBQWlCUyxPQUFPLENBQUNhLE9BQU87b0JBQ25DLEdBQUdILFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVFHLE9BQU87Z0JBQy9DO2dCQUNBQyxRQUFReUYsaUJBQWlCekYsTUFBTTtZQUNqQyxHQUFHQyxLQUFLLENBQUMsQ0FBQ0M7Z0JBQ1IsTUFBTUE7WUFDUjtZQUNBLElBQUlyQixZQUFZO2dCQUNkLElBQUk7b0JBQ0YsTUFBTUEsV0FBV087Z0JBQ25CLEVBQUUsT0FBT2MsS0FBSztvQkFDWixNQUFNQTtnQkFDUjtZQUNGO1lBQ0EsSUFBSSxDQUFDZCxJQUFJZSxFQUFFLEVBQUU7Z0JBQ1gsTUFBTSxJQUFJQyxNQUNSLE1BQU1oQixJQUFJeEMsSUFBSSxNQUFNO1lBRXhCO1lBQ0EsSUFBSSxDQUFDd0MsSUFBSUcsSUFBSSxFQUFFO2dCQUNiLE1BQU0sSUFBSWEsTUFBTTtZQUNsQjtZQUNBLElBQUlzRixTQUFTO1lBQ2IsTUFBTWpGLFNBQVNyQixJQUFJRyxJQUFJLENBQUNtQixTQUFTO1lBQ2pDLE1BQU0xRSxVQUFVRjtZQUNoQixNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFeUcsSUFBSSxFQUFFM0UsS0FBSyxFQUFFLEdBQUcsTUFBTTZDLE9BQU9TLElBQUk7Z0JBQ3pDLElBQUlxQixNQUFNO29CQUNSO2dCQUNGO2dCQUNBbUQsVUFBVTFKLFFBQVE0QjtnQkFDbEJVLE9BQU9vSCxRQUFRO2dCQUNmLElBQUlELHFCQUFxQixNQUFNO29CQUM3QmhGLE9BQU95QixNQUFNO29CQUNiO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJdEQsVUFBVTtnQkFDWkEsU0FBUzRHLFFBQVFFO1lBQ25CO1lBQ0FILG1CQUFtQjtZQUNuQixPQUFPRztRQUNULEVBQUUsT0FBT3hGLEtBQUs7WUFDWixJQUFJQSxJQUFJUCxJQUFJLEtBQUssY0FBYztnQkFDN0I0RixtQkFBbUI7Z0JBQ25CLE9BQU87WUFDVDtZQUNBLElBQUlyRixlQUFlRSxPQUFPO2dCQUN4QixJQUFJeUMsU0FBUztvQkFDWEEsUUFBUTNDO2dCQUNWO1lBQ0Y7WUFDQWtELFNBQVNsRDtRQUNYLFNBQVU7WUFDUmdELGNBQWM7UUFDaEI7SUFDRixHQUNBO1FBQ0U1RTtRQUNBNEU7UUFDQTlFO1FBQ0FLO1FBQ0E4RztRQUNBMUc7UUFDQUQ7UUFDQWlFO1FBQ0FPO0tBQ0Q7SUFFSCxNQUFNYyxPQUFPVyxrREFBWUEsQ0FBQztRQUN4QixJQUFJdkIsaUJBQWlCO1lBQ25CQSxnQkFBZ0JhLEtBQUs7WUFDckJvQixtQkFBbUI7UUFDckI7SUFDRixHQUFHO1FBQUNqQztLQUFnQjtJQUNwQixNQUFNcUMsZ0JBQWdCZCxrREFBWUEsQ0FDaEMsQ0FBQ2U7UUFDQ3RILE9BQU9zSCxhQUFhO0lBQ3RCLEdBQ0E7UUFBQ3RIO0tBQU87SUFFVixNQUFNdUgsV0FBV2hCLGtEQUFZQSxDQUMzQixPQUFPVyxRQUFRNUY7UUFDYixPQUFPeUQsZUFBZW1DLFFBQVE1RjtJQUNoQyxHQUNBO1FBQUN5RDtLQUFlO0lBRWxCLE1BQU0sQ0FBQ2lCLE9BQU9DLFNBQVMsR0FBR1UsK0NBQVNBLENBQUN0QztJQUNwQyxNQUFNNkIsZUFBZUssa0RBQVlBLENBQy9CLENBQUM5RztRQUNDQSxFQUFFMkcsY0FBYztRQUNoQixJQUFJLENBQUNKLE9BQ0g7UUFDRixPQUFPdUIsU0FBU3ZCO0lBQ2xCLEdBQ0E7UUFBQ0E7UUFBT3VCO0tBQVM7SUFFbkIsTUFBTWxCLG9CQUFvQixDQUFDNUc7UUFDekJ3RyxTQUFTeEcsRUFBRTZHLE1BQU0sQ0FBQ2hILEtBQUs7SUFDekI7SUFDQSxPQUFPO1FBQ0wwSDtRQUNBTztRQUNBNUg7UUFDQTBIO1FBQ0F6QjtRQUNBSTtRQUNBQztRQUNBSTtRQUNBSDtRQUNBdkI7SUFDRjtBQUNGO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kb2NzLXZlY3Rvci1zZWFyY2gtZGVtby8uL25vZGVfbW9kdWxlcy9haS9yZWFjdC9kaXN0L2luZGV4Lm1qcz8yYmZhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG4vLyByZWFjdC91c2UtY2hhdC50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlSWQsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IgZnJvbSBcInN3clwiO1xuXG4vLyBzaGFyZWQvdXRpbHMudHNcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZC9ub24tc2VjdXJlXCI7XG52YXIgbmFub2lkID0gY3VzdG9tQWxwaGFiZXQoXG4gIFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgN1xuKTtcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChnZXRTdHJlYW1TdHJpbmdUeXBlQW5kVmFsdWUpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgdGV4dDogMCxcbiAgZnVuY3Rpb25fY2FsbDogMSxcbiAgZGF0YTogMlxuICAvLyB1c2VyX2VycjogMz9cbn07XG52YXIgZ2V0U3RyZWFtU3RyaW5nVHlwZUFuZFZhbHVlID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBlcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBlcmF0b3JJbmRleCk7XG4gIGNvbnN0IHR5cGUgPSBPYmplY3Qua2V5cyhTdHJlYW1TdHJpbmdQcmVmaXhlcykuZmluZChcbiAgICAoa2V5KSA9PiBTdHJlYW1TdHJpbmdQcmVmaXhlc1trZXldID09PSBOdW1iZXIocHJlZml4KVxuICApO1xuICBjb25zdCB2YWwgPSBsaW5lLnNsaWNlKGZpcnN0U2VwZXJhdG9ySW5kZXggKyAxKTtcbiAgbGV0IHBhcnNlZFZhbCA9IHZhbDtcbiAgaWYgKCF2YWwpIHtcbiAgICByZXR1cm4geyB0eXBlLCB2YWx1ZTogXCJcIiB9O1xuICB9XG4gIHRyeSB7XG4gICAgcGFyc2VkVmFsID0gSlNPTi5wYXJzZSh2YWwpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwYXJzZSBKU09OIHZhbHVlOlwiLCB2YWwpO1xuICB9XG4gIHJldHVybiB7IHR5cGUsIHZhbHVlOiBwYXJzZWRWYWwgfTtcbn07XG52YXIgQ09NUExFWF9IRUFERVIgPSBcIlgtRXhwZXJpbWVudGFsLVN0cmVhbS1EYXRhXCI7XG5cbi8vIHJlYWN0L3VzZS1jaGF0LnRzXG52YXIgZ2V0U3RyZWFtZWRSZXNwb25zZSA9IGFzeW5jIChhcGksIGNoYXRSZXF1ZXN0LCBtdXRhdGUsIG11dGF0ZVN0cmVhbURhdGEsIGV4aXN0aW5nRGF0YSwgZXh0cmFNZXRhZGF0YVJlZiwgbWVzc2FnZXNSZWYsIGFib3J0Q29udHJvbGxlclJlZiwgb25GaW5pc2gsIG9uUmVzcG9uc2UsIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcHJldmlvdXNNZXNzYWdlcyA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gIG11dGF0ZShjaGF0UmVxdWVzdC5tZXNzYWdlcywgZmFsc2UpO1xuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIG1lc3NhZ2VzOiBzZW5kRXh0cmFNZXNzYWdlRmllbGRzID8gY2hhdFJlcXVlc3QubWVzc2FnZXMgOiBjaGF0UmVxdWVzdC5tZXNzYWdlcy5tYXAoXG4gICAgICAgICh7IHJvbGUsIGNvbnRlbnQsIG5hbWUsIGZ1bmN0aW9uX2NhbGwgfSkgPT4gKHtcbiAgICAgICAgICByb2xlLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgLi4ubmFtZSAhPT0gdm9pZCAwICYmIHsgbmFtZSB9LFxuICAgICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgLi4uKF9hID0gY2hhdFJlcXVlc3Qub3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmJvZHksXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uczogY2hhdFJlcXVlc3QuZnVuY3Rpb25zXG4gICAgICB9LFxuICAgICAgLi4uY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogY2hhdFJlcXVlc3QuZnVuY3Rpb25fY2FsbFxuICAgICAgfVxuICAgIH0pLFxuICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAuLi4oX2IgPSBjaGF0UmVxdWVzdC5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaGVhZGVyc1xuICAgIH0sXG4gICAgLi4uYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgIT09IG51bGwgJiYge1xuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5zaWduYWxcbiAgICB9XG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXMub2spIHtcbiAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgIHRocm93IG5ldyBFcnJvcihhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiKTtcbiAgfVxuICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXMuaGVhZGVycy5nZXQoQ09NUExFWF9IRUFERVIpID09PSBcInRydWVcIjtcbiAgY29uc3QgY3JlYXRlZEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCBkZWNvZGUgPSBjcmVhdGVDaHVua0RlY29kZXIoaXNDb21wbGV4TW9kZSk7XG4gIGxldCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGxldCByZXNwb25zZURhdGEgPSBbXTtcbiAgY29uc3QgcHJlZml4TWFwID0ge307XG4gIGNvbnN0IE5FV0xJTkUgPSBcIlxcblwiLmNoYXJDb2RlQXQoMCk7XG4gIGxldCBjaHVua3MgPSBbXTtcbiAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgaWYgKGlzQ29tcGxleE1vZGUpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSBORVdMSU5FKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbGV0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGNodW5rcy5sZW5ndGggPSAwO1xuICAgICAgdG90YWxMZW5ndGggPSAwO1xuICAgICAgY29uc3QgbGluZXMgPSBkZWNvZGUoY29uY2F0ZW5hdGVkQ2h1bmtzKTtcbiAgICAgIGlmICh0eXBlb2YgbGluZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCByZXNwb25zZSBmb3JtYXQuIENvbXBsZXggbW9kZSB3YXMgc2V0IGJ1dCB0aGUgcmVzcG9uc2UgaXMgYSBzdHJpbmcuIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB7IHR5cGUsIHZhbHVlOiB2YWx1ZTIgfSBvZiBsaW5lcykge1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAgICAgLi4ucHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAgICAgaWQ6IG5hbm9pZCgpLFxuICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZTIsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIpIHtcbiAgICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdID0gdmFsdWUyO1xuICAgICAgICAgIGxldCBmdW5jdGlvbkNhbGwgPSBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdO1xuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGwgJiYgdHlwZW9mIGZ1bmN0aW9uQ2FsbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRnVuY3Rpb25DYWxsID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsXG4gICAgICAgICAgICApLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0ge1xuICAgICAgICAgICAgICBpZDogbmFub2lkKCksXG4gICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBhcnNlZEZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICAgbmFtZTogcGFyc2VkRnVuY3Rpb25DYWxsLm5hbWUsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0gPSBmdW5jdGlvbkNhbGxNZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IEpTT04ucGFyc2UodmFsdWUyKTtcbiAgICAgICAgICBpZiAocHJlZml4TWFwW1wiZGF0YVwiXSkge1xuICAgICAgICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXSA9IFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdLCAuLi5wYXJzZWRWYWx1ZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZWZpeE1hcFtcImRhdGFcIl0gPSBwYXJzZWRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHByZWZpeE1hcFtcImRhdGFcIl07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCByZXNwb25zZU1lc3NhZ2VdLmZpbHRlcihcbiAgICAgICAgICBCb29sZWFuXG4gICAgICAgICk7XG4gICAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIC4uLm1lcmdlZF0sIGZhbHNlKTtcbiAgICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uZXhpc3RpbmdEYXRhIHx8IFtdLCAuLi5kYXRhIHx8IFtdXSwgZmFsc2UpO1xuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbdHlwZSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMocHJlZml4TWFwKSkge1xuICAgICAgaWYgKG9uRmluaXNoICYmIHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIG9uRmluaXNoKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgIHJlc3BvbnNlRGF0YS5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlcywgZGF0YTogcmVzcG9uc2VEYXRhIH07XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmVhbWVkUmVzcG9uc2UgPSBcIlwiO1xuICAgIGNvbnN0IHJlcGx5SWQgPSBuYW5vaWQoKTtcbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0ge1xuICAgICAgaWQ6IHJlcGx5SWQsXG4gICAgICBjcmVhdGVkQXQsXG4gICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIlxuICAgIH07XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0cmVhbWVkUmVzcG9uc2UgKz0gZGVjb2RlKHZhbHVlKTtcbiAgICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSkge1xuICAgICAgICByZXNwb25zZU1lc3NhZ2VbXCJmdW5jdGlvbl9jYWxsXCJdID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImNvbnRlbnRcIl0gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfVxuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEZ1bmN0aW9uQ2FsbCA9IEpTT04ucGFyc2Uoc3RyZWFtZWRSZXNwb25zZSkuZnVuY3Rpb25fY2FsbDtcbiAgICAgIHJlc3BvbnNlTWVzc2FnZVtcImZ1bmN0aW9uX2NhbGxcIl0gPSBwYXJzZWRGdW5jdGlvbkNhbGw7XG4gICAgICBtdXRhdGUoWy4uLmNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCB7IC4uLnJlc3BvbnNlTWVzc2FnZSB9XSk7XG4gICAgfVxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZTtcbiAgfVxufTtcbmZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSBcIi9hcGkvY2hhdFwiLFxuICBpZCxcbiAgaW5pdGlhbE1lc3NhZ2VzID0gW10sXG4gIGluaXRpYWxJbnB1dCA9IFwiXCIsXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5XG59ID0ge30pIHtcbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgY2hhdElkID0gaWQgfHwgaG9va0lkO1xuICBjb25zdCB7IGRhdGE6IG1lc3NhZ2VzLCBtdXRhdGUgfSA9IHVzZVNXUihbYXBpLCBjaGF0SWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsTWVzc2FnZXNcbiAgfSk7XG4gIGNvbnN0IHsgZGF0YTogaXNMb2FkaW5nID0gZmFsc2UsIG11dGF0ZTogbXV0YXRlTG9hZGluZyB9ID0gdXNlU1dSKFxuICAgIFtjaGF0SWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IHsgZGF0YTogc3RyZWFtRGF0YSwgbXV0YXRlOiBtdXRhdGVTdHJlYW1EYXRhIH0gPSB1c2VTV1IoXG4gICAgW2NoYXRJZCwgXCJzdHJlYW1EYXRhXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWYobWVzc2FnZXMgfHwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcyB8fCBbXTtcbiAgfSwgW21lc3NhZ2VzXSk7XG4gIGNvbnN0IGFib3J0Q29udHJvbGxlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZSgpO1xuICBjb25zdCB0cmlnZ2VyUmVxdWVzdCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IGFib3J0Q29udHJvbGxlcjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZShcbiAgICAgICAgICAgIGFwaSxcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0LFxuICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICAgICAgICAgIHN0cmVhbURhdGEsXG4gICAgICAgICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoXCJtZXNzYWdlc1wiIGluIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGxldCBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gZnVuY3Rpb25DYWxsUmVzcG9uc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzRm9sbG93aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDAgfHwgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjaGF0UmVxdWVzdCA9IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25FcnJvciAmJiBlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRFcnJvcihlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudFxuICAgIF1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKG1lc3NhZ2UsIHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKCFtZXNzYWdlLmlkKSB7XG4gICAgICAgIG1lc3NhZ2UuaWQgPSBuYW5vaWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQobWVzc2FnZSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh7IG9wdGlvbnMsIGZ1bmN0aW9ucywgZnVuY3Rpb25fY2FsbCB9ID0ge30pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzUmVmLmN1cnJlbnRbbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0TWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiKSB7XG4gICAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0MiA9IHtcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LmFib3J0KCk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldE1lc3NhZ2VzID0gdXNlQ2FsbGJhY2soXG4gICAgKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgbXV0YXRlKG1lc3NhZ2VzMiwgZmFsc2UpO1xuICAgICAgbWVzc2FnZXNSZWYuY3VycmVudCA9IG1lc3NhZ2VzMjtcbiAgICB9LFxuICAgIFttdXRhdGVdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2soXG4gICAgKGUsIHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsIH0gPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KVxuICAgICAgICByZXR1cm47XG4gICAgICBhcHBlbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZW50OiBpbnB1dCxcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHsgb3B0aW9ucywgZnVuY3Rpb25zLCBmdW5jdGlvbl9jYWxsIH1cbiAgICAgICk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgYXBwZW5kXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhXG4gIH07XG59XG5cbi8vIHJlYWN0L3VzZS1jb21wbGV0aW9uLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLCB1c2VJZCBhcyB1c2VJZDIsIHVzZVJlZiBhcyB1c2VSZWYyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB1c2VTV1IyIGZyb20gXCJzd3JcIjtcbmZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSBcIi9hcGkvY29tcGxldGlvblwiLFxuICBpZCxcbiAgaW5pdGlhbENvbXBsZXRpb24gPSBcIlwiLFxuICBpbml0aWFsSW5wdXQgPSBcIlwiLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3Jcbn0gPSB7fSkge1xuICBjb25zdCBob29rSWQgPSB1c2VJZDIoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuICBjb25zdCB7IGRhdGEsIG11dGF0ZSB9ID0gdXNlU1dSMihbYXBpLCBjb21wbGV0aW9uSWRdLCBudWxsLCB7XG4gICAgZmFsbGJhY2tEYXRhOiBpbml0aWFsQ29tcGxldGlvblxuICB9KTtcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1IyKFxuICAgIFtjb21wbGV0aW9uSWQsIFwibG9hZGluZ1wiXSxcbiAgICBudWxsXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUyKHZvaWQgMCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhO1xuICBjb25zdCBbYWJvcnRDb250cm9sbGVyLCBzZXRBYm9ydENvbnRyb2xsZXJdID0gdXNlU3RhdGUyKG51bGwpO1xuICBjb25zdCBleHRyYU1ldGFkYXRhUmVmID0gdXNlUmVmMih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5XG4gIH0pO1xuICB1c2VFZmZlY3QyKCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChwcm9tcHQsIG9wdGlvbnMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG11dGF0ZUxvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlcjIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIyKTtcbiAgICAgICAgbXV0YXRlKFwiXCIsIGZhbHNlKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYXBpLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyMi5zaWduYWxcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgbXV0YXRlKHJlc3VsdCwgZmFsc2UpO1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgICAgb25GaW5pc2gocHJvbXB0LCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIG11dGF0ZSxcbiAgICAgIG11dGF0ZUxvYWRpbmcsXG4gICAgICBhcGksXG4gICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgc2V0QWJvcnRDb250cm9sbGVyLFxuICAgICAgb25SZXNwb25zZSxcbiAgICAgIG9uRmluaXNoLFxuICAgICAgb25FcnJvcixcbiAgICAgIHNldEVycm9yXG4gICAgXVxuICApO1xuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2syKCgpID0+IHtcbiAgICBpZiAoYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICB9XG4gIH0sIFthYm9ydENvbnRyb2xsZXJdKTtcbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrMihcbiAgICAoY29tcGxldGlvbjIpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpO1xuICAgIH0sXG4gICAgW211dGF0ZV1cbiAgKTtcbiAgY29uc3QgY29tcGxldGUgPSB1c2VDYWxsYmFjazIoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KHByb21wdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3RdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUyKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrMihcbiAgICAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdXG4gICk7XG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGUpID0+IHtcbiAgICBzZXRJbnB1dChlLnRhcmdldC52YWx1ZSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29tcGxldGlvbixcbiAgICBjb21wbGV0ZSxcbiAgICBlcnJvcixcbiAgICBzZXRDb21wbGV0aW9uLFxuICAgIHN0b3AsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZ1xuICB9O1xufVxuZXhwb3J0IHtcbiAgdXNlQ2hhdCxcbiAgdXNlQ29tcGxldGlvblxufTtcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZUlkIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VTV1IiLCJjdXN0b21BbHBoYWJldCIsIm5hbm9pZCIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJjaHVuayIsImRlY29kZSIsInN0cmVhbSIsImRlY29kZWQiLCJzcGxpdCIsIm1hcCIsImdldFN0cmVhbVN0cmluZ1R5cGVBbmRWYWx1ZSIsImZpbHRlciIsIkJvb2xlYW4iLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInRleHQiLCJmdW5jdGlvbl9jYWxsIiwiZGF0YSIsImxpbmUiLCJmaXJzdFNlcGVyYXRvckluZGV4IiwiaW5kZXhPZiIsInByZWZpeCIsInNsaWNlIiwidHlwZSIsIk9iamVjdCIsImtleXMiLCJmaW5kIiwia2V5IiwiTnVtYmVyIiwidmFsIiwicGFyc2VkVmFsIiwidmFsdWUiLCJKU09OIiwicGFyc2UiLCJlIiwiY29uc29sZSIsImVycm9yIiwiQ09NUExFWF9IRUFERVIiLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiYXBpIiwiY2hhdFJlcXVlc3QiLCJtdXRhdGUiLCJtdXRhdGVTdHJlYW1EYXRhIiwiZXhpc3RpbmdEYXRhIiwiZXh0cmFNZXRhZGF0YVJlZiIsIm1lc3NhZ2VzUmVmIiwiYWJvcnRDb250cm9sbGVyUmVmIiwib25GaW5pc2giLCJvblJlc3BvbnNlIiwic2VuZEV4dHJhTWVzc2FnZUZpZWxkcyIsIl9hIiwiX2IiLCJwcmV2aW91c01lc3NhZ2VzIiwiY3VycmVudCIsIm1lc3NhZ2VzIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5Iiwic3RyaW5naWZ5Iiwicm9sZSIsImNvbnRlbnQiLCJuYW1lIiwib3B0aW9ucyIsImZ1bmN0aW9ucyIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsInNpZ25hbCIsImNhdGNoIiwiZXJyIiwib2siLCJFcnJvciIsImlzQ29tcGxleE1vZGUiLCJnZXQiLCJjcmVhdGVkQXQiLCJEYXRlIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVzcG9uc2VNZXNzYWdlcyIsInJlc3BvbnNlRGF0YSIsInByZWZpeE1hcCIsIk5FV0xJTkUiLCJjaGFyQ29kZUF0IiwiY2h1bmtzIiwidG90YWxMZW5ndGgiLCJyZWFkIiwicHVzaCIsImxlbmd0aCIsImNvbmNhdGVuYXRlZENodW5rcyIsIlVpbnQ4QXJyYXkiLCJvZmZzZXQiLCJzZXQiLCJsaW5lcyIsInZhbHVlMiIsImlkIiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsImZ1bmN0aW9uQ2FsbCIsInBhcnNlZEZ1bmN0aW9uQ2FsbCIsInBhcnNlZFZhbHVlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVyZ2VkIiwiY2FuY2VsIiwiaXRlbSIsImVudHJpZXMiLCJzdHJlYW1lZFJlc3BvbnNlIiwicmVwbHlJZCIsImRvbmUiLCJzdGFydHNXaXRoIiwidXNlQ2hhdCIsImluaXRpYWxNZXNzYWdlcyIsImluaXRpYWxJbnB1dCIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsIm9uRXJyb3IiLCJob29rSWQiLCJjaGF0SWQiLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsInNldEVycm9yIiwidHJpZ2dlclJlcXVlc3QiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlIiwiaGFzRm9sbG93aW5nUmVzcG9uc2UiLCJtZXNzYWdlIiwiZnVuY3Rpb25DYWxsUmVzcG9uc2UiLCJzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZSIsImFwcGVuZCIsImNvbmNhdCIsInJlbG9hZCIsImxhc3RNZXNzYWdlIiwiY2hhdFJlcXVlc3QyIiwic3RvcCIsImFib3J0Iiwic2V0TWVzc2FnZXMiLCJtZXNzYWdlczIiLCJpbnB1dCIsInNldElucHV0IiwiaGFuZGxlU3VibWl0IiwibWV0YWRhdGEiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZUlucHV0Q2hhbmdlIiwidGFyZ2V0IiwidXNlQ2FsbGJhY2syIiwidXNlRWZmZWN0MiIsInVzZUlkMiIsInVzZVJlZjIiLCJ1c2VTdGF0ZTIiLCJ1c2VTV1IyIiwidXNlQ29tcGxldGlvbiIsImluaXRpYWxDb21wbGV0aW9uIiwiY29tcGxldGlvbklkIiwiY29tcGxldGlvbiIsInNldEFib3J0Q29udHJvbGxlciIsInByb21wdCIsImFib3J0Q29udHJvbGxlcjIiLCJyZXN1bHQiLCJzZXRDb21wbGV0aW9uIiwiY29tcGxldGlvbjIiLCJjb21wbGV0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;